# [[Prototype]]

JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]
属性都会被赋予一个非空的值。

引用对象的属性时，会触发`[[GET]]`操作，对于默认的[[Get]]
操作来说，如果无法在对象本身找到需要的属性，就会继续访问对象的[[Prototype]]链。

使用`for..in`遍历对象时原理和查找`[[Prototype]]`链类似，任何可以通过原型链访问到并且是`enumerable`
的属性都会被枚举。使用`in`操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链`(无论属性是否可枚举)`。

当你通过各种语法进行属性查找时都会查找`[[Prototype]]`链，直到找到属性或者查找完整条原型链。

## Object.prototype

所有普通的`[[Prototype]]`链最终都会指向内置的`Object.prototype`

## 属性设置和屏蔽

```javascript
  myObject.foo = "bar";
```

如果`foo`不是直接存在于`myObject`中， `[[Prototype]]`链就会被遍历，类似`[[Get]]`操作。如果原型链上找不到`foo`, `foo`
就会被直接添加到`myObject`上。

### `[[prototype]]`发生屏蔽的三种情况

1. 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性， 并且没有被标记为只读（writable:false），
  那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。
2. 如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），
  那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。
  否则，这条赋值语句会被忽略。总之，不会发生屏蔽。
3. 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter。
  foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。

## "类"

在JavaScript中，类无法描述对象的行为，（因为根本就不存在类！）对象直接定义自己的行为。JavaScript中只有对象。

所有的函数默认都会拥有一个名为`prototype`的公有并且不可枚举的属性，它会指向另一个对象。

## 构造函数

> 在JavaScript中对于“构造函数”最准确的解释是，所有带new的函数调用。
> 
> 函数不是构造函数，但是当且仅当使用new时，函数调用会变成“构造函数调用”。

函数本身并不是构造函数，然而，当你在普通的函数调用前面加上`new`关键字之后，

就会把这个函数调用变成一个“构造函数调用”。实际上，new会劫持所有普通函数并用构造对象的形式来调用它。

> constructor并不表示被构造

`.constructor` 并不是一个不可变属性。它是不可枚举的，但是它的值是可写的

## 对象关联

[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象。